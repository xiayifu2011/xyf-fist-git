<h1 style="text-align:center">质数</h1>
2026.2.8

# First
  质数的定义：
   对于 $ p>1 $ 且 $ p\in\mathbb{N}$ 、
   若  $p$ 满足有且仅有 $\pm 1$ 与 $\pm p$ 两个因数
   则称 $p$ 为质数
# 质数判断
 - ## 单个质数判断
   发现:若$a \mid b$则$\frac{b}{a}\in \mathbb{Z} $
   故枚举$[1,\sqrt n]$内所有数即可,复杂度 $O(\sqrt n)$
   ```C++
    for(int i=1;i*i<=n;i++){
      if(n%i){
        return 0;
      }
    }
    return 1;
   ```
 - ## 筛
   ~~什么?埃氏筛?太慢了!上焚诀~~

   ### $O(n)$线性筛

   核心：用每个合数的==最小因数==标记 $[2,n]$ 区间内所有的合数，得到质数

   又因为任意合数的最小因数都为质数(非常好证)

   所以可以用已有质数表来枚举其最小因数
    
   ```C++
   vector<int>primes;
   bool is_prime[N];//标记是否为合数
   for(int k=2;k<=n;k++)//k有两个作用  
   {//1 充当遍历[2,n]时的指针,判断k,是否为质数
   //2 作为一个整数倍去标记质数p的倍数,即合数;注意这里的k为其标记合数的最大因数
     if(!is_prime[k]){
       prime.push_back(k);//如果在之前[2,k-1]内遍历时都没标记k,则k为质数
     }//注意把这坨代码放到最开始,不然下面在遍历质数时会漏掉质数的平方
     for(int i:primes){//这里的i也是被筛合数的最小因数
       if(i*k>n){
         break;//防越界
       }
       is_prime[i*k]=1;//质数i的k倍自然是合数
       if(k%i==0){
         break;//若i为k的因数,那么意味着,设k再乘上i往后的质数得到a
         //则a的最小因数就不是往后的质数,而是i
         //根据其核心原理,故弹出
       } 
     }
   }
   ```


- # 模
  - ## 定义
    若 
    $$
    \begin{align*}
    a & = qb+r \\
    a,b,q & \in \mathbb{Z},r \in \mathbb{Z} \text{且} r \in [0,b-1]\\
    \end{align*}
    $$ 
    则 $a \equiv r \pmod{b}$
    意为 $a$ 在模 $b$ 意义下 与 $r$ 同余
  - ## 性质
     若 $a \equiv b \pmod{m}$ 则 $xa+ym \equiv xb \pmod{m} (x,y \in \mathbb{Z})$
- # 逆元
  - ## 定义
    若 $ab \equiv 1 \pmod{m}$

    则称 $b$ 为 $a$ 在模 $m$ 意义下的逆元
    
    常记作 $a^{-1} \pmod{m}$ 或 $\text{inv}_m(a)$

    注意:并非所有 $a$ 在模 $m$ 意义下都有逆元 

    当 $\gcd(a,m)=1$ 时 $a$ 在模 $m$ 意义下都有逆元
  
  - ## 求解
    - ### 费马小定理
      若 $p$ 为质数,且 $\gcd(a,p)=1$ 则 $a^{-1} \pmod{p}=a^{p-2}$
      ```C++
        #define int long long
        int poewr(int x,int y,int mod){
          int ans=1;
          while(y>0){
            if(y&1){
              ans*=x;
              ans%=mod;
            }
            x*=x;
            x%=mod;
            y>>1;
          }
          return ans%mod;
        }//快速幂
        int main(){
          int a,p;
          cin>>a>>p;
          cout<<(power(a,p-2,p)+p)%p<<endl;//显然,a*a^{p-2}与a*(a^{p-2} mod p)在模 p意义下同余
          return 0;
        }
      ```
      费马定理其实是欧拉定理的特殊情况

     - ### 欧拉定理 
       ~~怎么哪里都有欧拉~~
       定义 $\varphi(n)$ 为 $[1,n-1]$ 内与 $n$ 互质(即gcd为1)的数的个数
       则
       $$
       \begin{align*}
       a^{\varphi(m)} & \equiv 1 \pmod{m}\\
       a^{\varphi(m)-1} & \equiv a^{-1} \pmod{m}\\
       \end{align*}
       $$
       怎么求 $\varphi(m)$ 呢
       $$
       \begin{align*}
       \text{令} m & =\prod_{i=1} p_i^{a_i}   \\ 
       (\forall p_i \in \mathbb{P},a_i \in \mathbb{N}^+) & \text{即质因数分解}\\
       \text{则}\varphi(m) & =m\prod_{i=1} \frac{p_i-1}{p_i}
       \end{align*}
       $$
       仅做了解,不适合在OI中使用
     - ### 扩展欧几里得
       欧几里得能干什么?
       求解形如 $ax+by=\gcd(a,b)$
       的不定方程的一组解

       显然,当 $ax \equiv 1 \pmod{m}$ 时, $ax+by \equiv 1 \pmod{m}$ ,这不就是欧几里得能干的事吗
       
       可以看出,扩欧比费马有着更广的使用范围

       ```C++
       struct GCD
        {
        int gcd_ans;
        int x;
        int y;
        };

        GCD ex_gcd(int a, int b, int x, int y)
        {
          if (b == 0)
          {
              return (GCD){a, 1, 0};
          }
          GCD last = ex_gcd(b, a % b, x, y);
          int next_x, next_y;
          next_x = last.y;
          next_y = last.x - (a / b) * last.y;
          return (GCD){last.gcd_ans, next_x, next_y};
        }//扩欧
        int ans,bns;
        int main(){
          int a,m;
          cin>>a>>m;
          GCD re=ex_gcd(a,m,ans,bns);
          cout<<ans<<endl;
        }
       ```
- # CRT中国剩余定理
  - ## 内容
    对于诸如下列形式的方程

    $$
    \begin{cases}
    x \equiv{a_1} \pmod{m_1}\\
    x \equiv{a_2} \pmod{m_2}\\
          \vdots \\
    x \equiv{a_n} \pmod{m_n}  
    \end{cases}
    $$
    当 $\forall i,j $ 都有 $ \gcd(m_i,m_j)=1$时 在模 $\prod_{i=1}^nm_i$ 意义下有唯一解
  - ## 求解
    令 
    $$
    \begin{align*}
    & M = \prod_{i=1}^n m_i\\
    & M_i=\frac{M}{m_i}\\
    & m_i \times t_i \equiv{1} \pmod{M}\\
    \end{align*}
    $$
    (求解 $t_i$ 可以使用扩欧)

    则解为
    $$
    \begin{align*}
    x \equiv \sum_{i=1}^n a_iM_it_i  \pmod{M}
    \end{align*}
    $$

2026.2.17



    
